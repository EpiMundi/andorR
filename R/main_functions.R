#############################################################################
# Load trees in different formats
#############################################################################

#' @title Build the decision tree from a data frame
#' @description Takes a data frame with a specific parent-child structure and
#' converts it into a data.tree object, initializing necessary attributes.
#' @param df A data frame with columns: id, name, question, rule, parent.
#' @return A data.tree object.
#' @importFrom data.tree Node
#' @export
load.tree.df <- function(df) {

  node_list <- list()

  # First pass: Create all nodes and store their attributes from the dataframe
  for (i in 1:nrow(df)) {
    row <- df[i, ]
    # Use the 'name' column for the node's display name
    node <- Node$new(row$name)

    # Copy all relevant columns as attributes to the node object
    node$id <- row$id
    node$question <- row$question
    node$rule <- row$rule
    node$parent_id <- row$parent # Store parent id for the linking step

    # Initialize the dynamic attributes for the analysis
    node$answer <- NA
    node$confidence <- NA

    # Add the newly created node to our lookup list
    node_list[[as.character(row$id)]] <- node
  }

  # Second pass: Link the nodes together into a tree structure
  for (node in node_list) {
    # Check if the node has a parent (the root will have NA)
    if (!is.na(node$parent_id)) {
      # Find the parent node in our list using its ID
      parent_node <- node_list[[as.character(node$parent_id)]]

      # Add the current node as a child of its parent
      if (!is.null(parent_node)) {
        parent_node$AddChildNode(node)
      }
    }
  }

  # The root of the tree is the node with id = 0
  tree <- node_list[['0']]

  return(tree)
}

#' @title Build a decision tree from a nested list
#' @description This is the core function for converting a nested R list, typically
#'   generated by reading a YAML file, into a `data.tree` object. It constructs
#'   the tree hierarchy and initializes the `answer` and `confidence` attributes
#'   required for the analysis.
#'
#' @details
#' This function serves as a low-level constructor called by wrapper functions
#' like `load.tree.yaml()`. It uses `data.tree::as.Node()` to parse the list
#' structure and then traverses the new tree to set default `NA` values.
#'
#' @param data_list A nested R list representing the tree structure. Each list
#'   element should have a `name` and can have other attributes like `question`,
#'   `rule`, and a sub-list named `nodes` containing its children.
#'
#' @return A `data.tree` object, fully constructed and initialized with `answer`
#'   and `confidence` attributes set to `NA`.
#'
#' @importFrom data.tree as.Node
#' @export
#'
load.tree.node.list <- function(data_list) {

  # 1. Convert the list into a data.tree Node object
  tree <- as.Node(data_list)

  # 2. Initialize the dynamic attributes for all nodes.
  tree$Do(function(node) {
    node$answer <- NA
    node$confidence <- NA
  })

  return(tree)
}

#' @title Load a decision tree from a CSV file
#' @description A wrapper function that reads a CSV file into a data frame
#'   and then uses `load.tree.df` to construct the tree object.
#' @param file_path The path to the .csv file. The file is expected to have
#'   columns: id, name, question, rule, parent.
#' @return A `data.tree` object.
#' @importFrom utils read.csv
#' @export
#' @examples
#' \dontrun{
#' # Assuming "my_decision_tree.csv" is in the working directory
#' my_tree <- load.tree.csv("my_decision_tree.csv")
#' }
load.tree.csv <- function(file_path) {
  if (!file.exists(file_path)) {
    stop(paste("File not found at path:", file_path), call. = FALSE)
  }

  # Read the data from the CSV file
  df <- utils::read.csv(file_path, stringsAsFactors = FALSE)

  # Call your existing function to build the tree from the data frame
  tree <- load.tree.df(df)

  return(tree)
}

#' @title Load a decision tree from a YAML file
#' @description A wrapper function that reads a YAML file into a nested list
#'   and then uses `load.tree.node.list` to construct the tree object.
#' @param file_path The path to the .yml or .yaml file.
#' @return A `data.tree` object.
#' @importFrom yaml read_yaml
#' @export
#' @examples
#' \dontrun{
#' # Assuming "my_decision_tree.yml" is in the working directory
#' my_tree <- load.tree.yaml("my_decision_tree.yml")
#' }
load.tree.yaml <- function(file_path) {
  if (!file.exists(file_path)) {
    stop(paste("File not found at path:", file_path), call. = FALSE)
  }

  # Read the data from the YAML file into a list
  data_list <- yaml::read_yaml(file_path)

  # Call your existing function to build the tree from the list
  tree <- load.tree.node.list(data_list)

  return(tree)
}

#' @title Print a Formatted Summary of the Decision Tree
#' @description
#' Displays the `data.tree` object in the console with a custom set of columns
#' (`Rule`, `Answer`, `Confidence`) formatted for readability. This function is
#' the standard way to view the tree's state during an analysis.
#'
#' @details
#' This function provides a consistent, clean view of the tree's current state.
#' It formats the `Confidence` attribute to show the 0-5 scale for leaves
#' and a percentage for parent nodes. It also hides `NA` values for all
#' attributes to reduce clutter.
#'
#' @param tree The `data.tree` object (the root `Node`) to be printed.
#'
#' @return The original `tree` object (returned invisibly).
#' @export
#' @examples
#' \dontrun{
#' # Assuming 'my_tree' is a loaded andorR tree object
#' print_tree_status(my_tree)
#' }
print_status <- function(tree) {

  # Helper "getter" functions to format the columns for printing
  get_rule_str <- function(node) {
    if (is.null(node$rule) || is.na(node$rule)) "" else as.character(node$rule)
  }

  get_answer_str <- function(node) {
    if (is.na(node$answer)) "" else as.character(node$answer)
  }

  get_confidence_str <- function(node) {
    if (is.na(node$confidence)) {
      return("")
    }
    if (node$isLeaf) {
      # Back-convert to 0-5 scale for leaves
      return(as.character(round((node$confidence - 0.5) * 10, 1)))
    } else {
      # Show percentage for parent nodes
      return(paste0(round(node$confidence * 100, 1), "%"))
    }
  }

  # The main print call using the helper functions
  print(tree,
        "Rule" = get_rule_str,
        "Answer" = get_answer_str,
        "Confidence" = get_confidence_str)

  invisible(tree)
}

#' @title Print a Styled, Formatted Summary of the Decision Tree
#' @description
#' Displays a clean, perfectly aligned, color-coded summary of the tree's
#' current state, with color propagation up the branches.
#'
#' @param tree The `data.tree` object (the root `Node`) to be printed.
#'
#' @return The original `tree` object (returned invisibly).
#' @importFrom cli col_green col_red col_cyan col_blue style_bold ansi_strip
#' @importFrom crayon strip_style
#' @export
pretty_print <- function(tree) {

  # --- Stage 1: Pre-calculation of Branch Colors ---
  determine_branch_color <- function(node) {
    color <- "plain"
    if (isTRUE(node$answer)) {
      color <- "green"
    } else if (isFALSE(node$answer)) {
      color <- "red"
    } else {
      if (!node$isLeaf) {
        child_colors <- sapply(node$children, function(child) child$branch_color)
        rule <- node$rule
        if (!is.na(rule)) {
          if (rule == "AND") {
            if ("red" %in% child_colors) color <- "red"
            else if ("green" %in% child_colors) color <- "green"
          } else if (rule == "OR") {
            if ("green" %in% child_colors) color <- "green"
            else if ("red" %in% child_colors) color <- "red"
          }
        }
      }
    }
    node$branch_color <- color
  }
  tree$Do(determine_branch_color, traversal = "post-order")

  # --- Stage 2: Printing ---

  col_starts <- c(Tree = 0, Rule = 50, Answer = 60, Confidence = 72)
  tree_col_width <- col_starts["Rule"] - 2

  # A single helper to print one formatted line
  print_formatted_line <- function(node, prefix = "") {
    style_func <- switch(node$branch_color, green = cli::col_green, red = cli::col_red, function(x) x)

    # MODIFIED: Removed style_bold()
    styled_name <- style_func(node$name)

    tree_part <- paste0(prefix, styled_name)
    if (nchar(crayon::strip_style(tree_part)) > tree_col_width) {
      overflow <- nchar(crayon::strip_style(tree_part)) - tree_col_width + 3
      new_name_len <- nchar(node$name) - overflow
      if (new_name_len < 1) new_name_len <- 1
      trunc_name <- paste0(strtrim(node$name, new_name_len), "...")
      # MODIFIED: Removed style_bold() from truncation logic as well
      styled_name <- style_func(trunc_name)
      tree_part <- paste0(prefix, styled_name)
    }

    rule_str <- if (!is.na(node$rule)) cli::col_cyan(node$rule) else ""
    answer_str <- if (!is.na(node$answer)) style_func(toupper(as.character(node$answer))) else ""
    conf_str <- ""
    if (!is.na(node$confidence)) {
      if (node$isLeaf) conf_str <- cli::col_cyan(as.character(round((node$confidence - 0.5) * 10, 1)))
      else conf_str <- cli::col_blue(paste0(round(node$confidence * 100, 1), "%"))
    }

    line <- tree_part
    padding1 <- paste(rep(" ", max(1, col_starts["Rule"] - nchar(crayon::strip_style(line)))), collapse = "")
    line <- paste0(line, padding1, rule_str)
    padding2 <- paste(rep(" ", max(1, col_starts["Answer"] - nchar(crayon::strip_style(line)))), collapse = "")
    line <- paste0(line, padding2, answer_str)
    padding3 <- paste(rep(" ", max(1, col_starts["Confidence"] - nchar(crayon::strip_style(line)))), collapse = "")
    line <- paste0(line, padding3, conf_str)

    cat(line, "\n")
  }

  # The recursive helper function
  print_children_recursive <- function(parent_node, ancestors_is_last) {
    children <- parent_node$children
    n_children <- length(children)
    if (n_children == 0) return()

    for (i in 1:n_children) {
      child <- children[[i]]
      is_last <- (i == n_children)

      prefix <- ""
      if(length(ancestors_is_last) > 0) {
        for(j in 1:length(ancestors_is_last)) {
          ancestor <- child$ancestors[[j]]
          color_name <- ancestor$branch_color
          if (is.null(color_name)) color_name <- "plain"
          style_func <- switch(color_name, green = cli::col_green, red = cli::col_red, function(x) x)
          indent_segment <- if (ancestors_is_last[[j]]) "    " else "|   "
          prefix <- paste0(prefix, style_func(indent_segment))
        }
      }

      child_style <- switch(child$branch_color, green = cli::col_green, red = cli::col_red, function(x) x)
      connector <- if (is_last) "`-- " else "|-- "
      styled_connector <- child_style(connector)

      # This is the line-printing logic that also needed to be changed
      # It now calls the single, corrected print_formatted_line helper
      print_formatted_line(child, paste0(prefix, styled_connector))

      print_children_recursive(child, c(ancestors_is_last, is_last))
    }
  }

  # --- Main Function Body ---

  # Restructuring the main body to remove duplicated code
  header <- sprintf("%-*s%-*s%-*s%-*s",
                    col_starts["Rule"]-1, "Tree",
                    col_starts["Answer"]-col_starts["Rule"], "Rule",
                    col_starts["Confidence"]-col_starts["Answer"], "Answer",
                    12, "Confidence")
  cat(cli::style_bold(header), "\n")

  # Print root and start recursion
  print_formatted_line(tree, "")
  print_children_recursive(tree, c())

  invisible(tree)
}


###########################################################################
# Tree analysis and processing functions
###########################################################################


#' Propagate Answers and Confidence Up the Tree
#'
#' @description
#' This function performs a full, bottom-up recalculation of the decision tree's
#' state. It takes the user-provided answers and confidences at the leaf level
#' and propagates the logical outcomes (`answer`) and aggregate confidence scores
#' up to the parent nodes based on their `AND`/`OR` rules.
#'
#' @details
#' The function first resets the `answer` and `confidence` of all non-leaf nodes
#' to `NA` to ensure a clean calculation.
#'
#' It then uses a **post-order traversal**, which is critical as it guarantees
#' that a parent node is only processed after all of its children have been processed.
#'
#' The logical rules are applied with short-circuiting:
#' - **OR Nodes:** Become `TRUE` if any child is `TRUE`. Become `FALSE` only if
#'   all children are answered and none are `TRUE`.
#' - **AND Nodes:** Become `FALSE` if any child is `FALSE`. Become `TRUE` only if
#'   all children are answered and none are `FALSE`.
#'
#' The confidence calculation is based on the confidences of the children that
#' determined the outcome (e.g., only the `TRUE` children for a resolved `OR` node).
#'
#' @param tree The `data.tree` object to be calculated. The function modifies
#'   this object directly.
#'
#' @return The modified `tree` object (returned invisibly).
#' @import glue
#' @export
#'
calculate_tree <- function(tree) {
  tree$Do(function(node) {
    if (!node$isLeaf) {
      node$answer <- NA
      node$confidence <- NA
    }
  })
  tree$Do(function(node) {
    if (node$isLeaf) return()
    if (length(node$children) == 0) return()
    children_answers <- sapply(node$children, function(ch) ch$answer)
    if (length(children_answers) > 0) {
      children_answers <- as.logical(children_answers)
    }
    rule <- node$rule
    if (is.null(rule) || is.na(rule) || rule == "") return()
    rule <- toupper(trimws(as.character(rule)))
    new_answer <- NA
    new_confidence <- NA
    children_confidences <- sapply(node$children, function(ch) ch$confidence)
    relevant_confidences <- children_confidences[!is.na(children_answers)]
    if (rule == "OR") {
      if (any(children_answers == TRUE, na.rm = TRUE)) {
        new_answer <- TRUE
        true_confidences <- children_confidences[which(children_answers == TRUE)]
        if(length(true_confidences) > 0) {
          new_confidence <- 1 - prod(1 - true_confidences, na.rm = TRUE)
        }
      } else if (all(!is.na(children_answers))) {
        new_answer <- FALSE
        if(length(relevant_confidences) > 0) {
          new_confidence <- 1 - prod(1 - relevant_confidences, na.rm = TRUE)
        }
      }
    } else if (rule == "AND") {
      if (any(children_answers == FALSE, na.rm = TRUE)) {
        new_answer <- FALSE
        false_confidences <- children_confidences[which(children_answers == FALSE)]
        if(length(false_confidences) > 0) {
          new_confidence <- prod(false_confidences, na.rm = TRUE)
        }
      } else if (all(!is.na(children_answers))) {
        new_answer <- TRUE
        if(length(relevant_confidences) > 0) {
          new_confidence <- prod(relevant_confidences, na.rm = TRUE)
        }
      }
    }
    if (!is.na(new_answer)) {
      node$answer <- new_answer
      node$confidence <- new_confidence
    }
  }, traversal = "post-order")
  invisible(tree)
}


#' @title Calculate Dynamic True/False Indices for a Parent Node
#'
#' @description
#' This function calculates a `true_index` and a `false_index` for a given parent
#' (non-leaf) node. The calculation is dynamic, depending on the node's logical
#' rule (`AND` or `OR`) and the number of its direct children that have not yet
#' been answered (i.e., their `answer` attribute is `NA`).
#'
#' @details
#' The function applies the following logic:
#' - For an **AND** node, `true_index` is `1/n` and `false_index` is `1.0`.
#' - For an **OR** node, `true_index` is `1.0` and `false_index` is `1/n`.
#'
#' Where `n` is the number of unanswered children. If all children have been
#' answered (`n = 0`), `n` is treated as 1 to avoid division by zero.
#'
#' The function modifies the node object directly by adding or updating the
#' `true_index` and `false_index` attributes. It is intended to be used with
#' `tree$Do()`.
#'
#' @param node A `data.tree` `Node` object to be processed. The function will
#'   only act on this node if it is not a leaf (`!node$isLeaf`).
#'
#' @return The function does not return a value; it modifies the input `node`
#'   by side-effect.
#'
#' @keywords internal
#'
assign_indices <- function(node) {
  if (!node$isLeaf) {
    children_answers <- sapply(node$children, function(ch) ch$answer)
    unanswered_count <- sum(is.na(children_answers))
    if (unanswered_count == 0) unanswered_count <- 1
    if (!is.na(node$rule) && node$rule == "AND") {
      node$true_index <- 1 / unanswered_count
      node$false_index <- 1.0
    } else if (!is.na(node$rule) && node$rule == "OR") {
      node$true_index <- 1.0
      node$false_index <- 1 / unanswered_count
    }
  }
}

#' @title Calculate the Influence Index for a Leaf Node
#'
#' @description
#' Determines the strategic importance (the "influence") of asking an unanswered
#' leaf question. The influence is calculated by aggregating the logical indices
#' (`true_index` and `false_index`) of all its ancestor nodes.
#'
#' @details
#' The influence index is a measure of how much a single leaf's answer can
#' contribute to the final conclusion. It is calculated as the sum of two
#' products:
#' Influence = `prod(ancestor_true_indices) + prod(ancestor_false_indices)`
#'
#' The function will set `influence_index` to `NA` under two conditions,
#' as the question is considered moot:
#' 1.  The leaf node itself has already been answered.
#' 2.  Any of the leaf's ancestors has a determined `answer` (`TRUE` or `FALSE`),
#'     meaning the branch has already been logically resolved.
#'
#' This function is intended to be used with `tree$Do(..., filterFun = isLeaf)`.
#'
#' @param node A `data.tree` `Node` object, which must be a leaf.
#'
#' @return The function has no return value; it modifies the `influence_index`
#'   attribute of the input `node` by side-effect.
#'
#' @keywords internal
#'
calculate_influence <- function(node) {
  if (!is.na(node$answer)) {
    node$influence_index <- NA
    return()
  }
  ancestor_answers <- unlist(node$Get("answer", traversal = "ancestor"))
  if (any(!is.na(ancestor_answers))) {
    node$influence_index <- NA
    return()
  }
  true_indices_vec <- node$Get('true_index', traversal = "ancestor")
  false_indices_vec <- node$Get('false_index', traversal = "ancestor")
  ancestor_true_indices <- true_indices_vec[-1]
  ancestor_false_indices <- false_indices_vec[-1]
  prod_true <- prod(ancestor_true_indices, na.rm = TRUE)
  prod_false <- prod(ancestor_false_indices, na.rm = TRUE)
  node$influence_index <- prod_true + prod_false
}

#' @title Identify the Most Influential Question(s)
#'
#' @description
#' Scans all leaf nodes in the tree to find the one or more questions that
#' currently have the highest `influence_index`. This is the core function for
#' guiding the user to the next most impactful question to answer during the
#' interactive analysis loop.
#'
#' @details
#' The function works by:
#' 1. Gathering all leaf nodes from the tree.
#' 2. Filtering out any leaves that have already been answered or are part of an
#'    already-resolved logical branch (where `influence_index` is `NA`).
#' 3. Finding the maximum `influence_index` among the remaining eligible leaves.
#' 4. Returning a data frame of all leaves that share this maximum score.
#'
#' @param tree The main `data.tree` object for the analysis. It is expected that
#'   the `calculate_influence` function has already been run on the tree.
#'
#' @return A `data.frame` (technically a tibble) containing the `name`, `influence_index`, and
#'   `question` for the highest-influence leaf/leaves. Returns `NULL` invisibly if
#'   no eligible (unanswered) questions remain.
#' @importFrom dplyr %>% filter select
#' @export
#'
get_highest_influence <- function(tree) {
  leaf_data <- data.frame(
    is_leaf = tree$Get("isLeaf"),
    name = tree$Get("name"),
    influence_index = tree$Get("influence_index"),
    question = tree$Get("question")
  )
  eligible_leaves <- leaf_data %>%
    filter(is_leaf == TRUE, !is.na(influence_index))
  if (nrow(eligible_leaves) == 0) return(invisible(NULL))
  max_influence <- max(eligible_leaves$influence_index, na.rm = TRUE)
  highest_influence_leaves <- eligible_leaves %>%
    filter(influence_index == max_influence) %>%
    select(name, influence_index, question)
  return(highest_influence_leaves)
}

#' @title Find Actions to Most Effectively Boost Confidence
#' @description Performs a sensitivity analysis on the tree to find which actions
#' (answering a new question or increasing confidence in an old one) will have
#' the greatest positive impact on the root node's final confidence score.
#' @param tree The current data.tree object, typically after a conclusion is reached.
#' @param top_n The number of suggestions to return.
#' @return A data.frame of the top_n suggested actions, ranked by potential gain.
#' @importFrom data.tree Traverse Clone FindNode
#' @importFrom dplyr %>% filter arrange desc
#' @importFrom utils head
#' @importFrom cli cli_process_start cli_process_done symbol
#' @export
get_confidence_boosters <- function(tree, top_n = 5) {

  current_root_conf <- tree$confidence
  if (is.na(current_root_conf)) {
    cat("Cannot provide guidance until an initial conclusion is reached.\n")
    return(invisible(NULL))
  }

  suggestions <- list()

  # --- Analysis 1: Find the impact of answering NEW questions ---
  unanswered_leaves <- Traverse(tree, filterFun = function(node) node$isLeaf && is.na(node$answer))

  if (length(unanswered_leaves) > 0) {
    # start the spinner
    id <- cli_process_start("Analysing {length(unanswered_leaves)} unanswered questions...")
    # start the loop
    for (leaf in unanswered_leaves) {
      # Simulate answering TRUE with max confidence (5)
      tree_clone_t <- data.tree::Clone(tree)
      node_in_clone_t <- FindNode(tree_clone_t, leaf$name)
      if (!is.null(node_in_clone_t)) {
        node_in_clone_t$answer <- TRUE
        node_in_clone_t$confidence <- 1.0
      }
      calculate_tree(tree_clone_t)
      conf_if_true <- tree_clone_t$root$confidence

      # Simulate answering FALSE with max confidence (5)
      tree_clone_f <- data.tree::Clone(tree)
      node_in_clone_f <- FindNode(tree_clone_f, leaf$name)
      if (!is.null(node_in_clone_f)) {
        node_in_clone_f$answer <- FALSE
        node_in_clone_f$confidence <- 1.0
      }
      calculate_tree(tree_clone_f)
      conf_if_false <- tree_clone_f$root$confidence

      # Determine which answer provides a better potential outcome
      gain_t <- ifelse(is.na(conf_if_true), 0, conf_if_true - current_root_conf)
      gain_f <- ifelse(is.na(conf_if_false), 0, conf_if_false - current_root_conf)

      if (gain_t > gain_f) {
        suggestions[[leaf$name]] <- list(action = "Answer New Question",
                                         name = leaf$name,
                                         question = leaf$question,
                                         details = "Suggest answering TRUE",
                                         potential_gain = gain_t)
      } else {
        suggestions[[leaf$name]] <- list(action = "Answer New Question",
                                         name = leaf$name,
                                         question = leaf$question,
                                         details = "Suggest answering FALSE",
                                         potential_gain = gain_f)
      }
    }
    cli_process_done(id, "Analysed {length(unanswered_leaves)} unanswered questions {symbol$tick}")
  }

  # --- Analysis 2: Find the impact of increasing confidence on OLD answers ---
  answered_leaves <- Traverse(tree, filterFun = function(node) node$isLeaf && !is.na(node$answer) && node$confidence < 1.0)

  if (length(answered_leaves) > 0) {
    id2 <- cli_process_start("Analysing {length(answered_leaves)} existing answers...")

    for (leaf in answered_leaves) {
      # Simulate re-answering with max confidence
      tree_clone <- data.tree::Clone(tree)
      node_in_clone <- FindNode(tree_clone, leaf$name)
      if (!is.null(node_in_clone)) {
        node_in_clone$confidence <- 1.0
      }
      calculate_tree(tree_clone)
      conf_if_max <- tree_clone$root$confidence

      gain <- ifelse(is.na(conf_if_max), 0, conf_if_max - current_root_conf)

      if (gain > 0 && (is.null(suggestions[[leaf$name]]) || gain > suggestions[[leaf$name]]$potential_gain)) {
        current_conf_0_5 <- (leaf$confidence - 0.5) * 10
        suggestions[[leaf$name]] <- list(action = "Increase Confidence",
                                         name = leaf$name,
                                         question = leaf$question, # THE FIX IS HERE
                                         details = paste0("Current conf: ", round(current_conf_0_5, 1), "/5"),
                                         potential_gain = gain)
      }
    }
    cli_process_done(id2, "Analysed {length(answered_leaves)} existing answers {symbol$tick}")
  }

  if (length(suggestions) == 0) {
    cat("No further actions found to boost confidence.\n")
    return(data.frame())
  }

  # --- Combine, rank, and return the results ---
  results_df <- do.call(rbind.data.frame, suggestions)
  results_df <- results_df %>%
    filter(potential_gain > 0) %>%
    arrange(desc(potential_gain)) %>%
    head(top_n)

  if(nrow(results_df) > 0) {
    results_df$potential_gain <- paste0("+", round(results_df$potential_gain * 100, 2), "%")
  } else {
    cat("No further actions found to boost confidence.\n")
    return(data.frame())
  }

  return(results_df)
}


#' @title Set an Answer and Confidence for a Leaf Node
#'
#' @description
#' This is the primary function for providing evidence to the tree. It finds a
#' specific leaf node by its name and updates its `answer` and `confidence`
#' attributes based on user input.
#'
#' @details
#' The function takes a 0-5 confidence level from the user and converts it to an
#' internal score between 0.5 (uncertain) and 1.0 (certain) using the formula:
#' `score = 0.5 + (confidence_level / 10)`.
#'
#' It includes validation to ensure the target node exists, is a leaf, and that
#' the provided response is a valid logical value. A confirmation message is
#' printed to the console upon successful update.
#'
#' @param tree The `data.tree` object to be modified.
#' @param node_name A character string specifying the `name` of the leaf node to update.
#' @param response A logical value, `TRUE` or `FALSE`, representing the answer.
#' @param confidence_level A numeric value from 0 to 5 representing the user's
#'   confidence in the answer.
#'
#' @return Returns the modified `tree` object invisibly, which allows for function chaining.
#'
#' @importFrom data.tree FindNode
#' @export
#' @examples
#' # Create a simple tree
#' tree <- data.tree::Node$new("Root")
#' tree$AddChild("A1", answer = NA, confidence = NA)
#' tree$AddChild("A2", answer = NA, confidence = NA)
#'
#' # Set an answer for leaf 'A1'
#' tree <- set_answer(tree, "A1", TRUE, 5)
#' print(tree, "answer", "confidence")
#'
set_answer <- function(tree, node_name, response, confidence_level) {
  node_to_update <- FindNode(tree, node_name)
  if (is.null(node_to_update)) {
    warning(paste0("Node '", node_name, "' not found in the tree."), call. = FALSE)
    return(invisible(tree))
  }
  if (!node_to_update$isLeaf) {
    warning(paste0("Node '", node_name, "' is a parent node. Answers can only be set for leaves."), call. = FALSE)
    return(invisible(tree))
  }
  if (!is.logical(response) || is.na(response)) {
    warning("Invalid response. Please provide TRUE or FALSE.", call. = FALSE)
    return(invisible(tree))
  }
  node_to_update$answer <- response
  node_to_update$confidence <- 0.5 + (confidence_level / 10)
  cat(paste("Answer for leaf '", node_name, "' set to: ", response,
            " with confidence ", confidence_level, "/5\n", sep = ""))
  return(invisible(tree))
}


#' @title Update a Tree Based on Answers Provided
#'
#' @description
#' Propagate the results up to the tree nodes based on the answers provided,
#' and update the influence index to identify most important questions.
#'
#' @param tree The `data.tree` object to be modified.
#'
#' @return Returns the modified `tree` object invisibly, which allows for function chaining.
#' @importFrom data.tree isLeaf
#'
#' @export
update_tree <- function(tree) {
  tree <- calculate_tree(tree)
  tree$Do(assign_indices)
  tree$Do(calculate_influence, filterFun = isLeaf)
  return(tree)
}



###########################################################################
# Interactive analysis loop
###########################################################################

#' @title Print the introductory welcome message
#' @description Displays a formatted welcome screen for the tool, including
#'   metadata, author, and license information, using the `cli` package for
#'   styling.
#' @return This function is called for its side effect of printing to the
#'   console and does not return a value.
#' @importFrom cli boxx cli_text cli_rule cli_ul cli_alert_info
#' @importFrom utils packageVersion
#' @export
print_intro <- function() {

  # Try to get the package version dynamically
  version_string <- tryCatch({
    as.character(utils::packageVersion("andorR"))
  }, error = function(e) {
    "in-development"
  })

  cli::cli_h1("andorR")
  cli::cli_text("{.emph An analysis and optimisation tool for AND-OR decision trees.}")
  cli::cli_text("") # Spacer line

  cli::cli_text("Created by: EpiMundi ({.url https://epimundi.com})")
  cli::cli_text("Authors:    {.strong Angus Cameron} and {.strong Joao Romero}")
  cli::cli_text("Email:      angus@epimundi.com")
  cli::cli_text("Version:    {version_string}")
  cli::cli_text("")

  # Use a rule for the license section
  cli::cli_rule(left = "{.strong License: CC BY-ND 4.0}")

  cli::cli_text("This tool is free to use and share under these conditions:")

  # Use an unordered list for the conditions
  items <- c(
    "You must give appropriate credit ({.strong Attribution}).",
    "You may not distribute modified versions ({.strong No Derivatives})."
  )
  cli::cli_ul(items)

  cli::cli_text("Full license details: {.url https://creativecommons.org/licenses/by-nd/4.0/}")
  cli::cli_text("")
}



#' @title Enter Interactive Analysis Mode
#'
#' @description
#' Iteratively prompts the user to answer questions to solve a decision tree.
#' The function first presents the most impactful unanswered questions. Once the
#' tree's root is solved, it presents questions that can increase the overall
#' confidence of the conclusion.
#'
#' @details
#' This function provides a command-line interface (CLI) for working with the
#' tree. It uses the `cli` package for formatted output and handles user input
#' for quitting, saving, printing the tree state, or providing answers to
#' specific questions (either by number or by name). All tree modifications are
#' performed by calling the package's existing API functions like `set_answer()`
#' and `update_tree()`.
#'
#' @param tree The `data.tree` object to be analysed.
#'
#' @return The final, updated `data.tree` object.
#' @importFrom data.tree FindNode isLeaf ToDataFrameTypeCol
#' @importFrom cli cli_alert_danger cli_alert_info cli_alert_success cli_div cli_dl cli_h1 cli_h2 cli_ol cli_rule cli_text col_red col_cyan col_yellow style_bold
#' @importFrom dplyr %>% filter select arrange
#' @importFrom rlang .data
#' @importFrom stats setNames
#' @export
andorR_interactive <- function(tree) {

  # --- Local Helper Function to display the help menu ---
  # ------------------------------------------------------
  display_interactive_help <- function() {
    cli_div(theme = list(rule = list(color = "blue")))
    cli_rule(left = style_bold("Help Menu"))
    cli_text( col_red("h"), ": Show this help message.")
    cli_text( col_red("q"), ": Quit the interactive session.")
    cli_text( col_red("p"), ": Print the current state of the tree.")
    cli_text( col_red("s"), ": Save the current tree state to an .rds file.")
    cli_text( col_red("n"), ": Specify a node to edit by typing its name.")
    cli_text( col_red("1, 2, ..."), ": Select a numbered question from the list to answer.")
    cli_rule()
  }

  # --- Local Helper Function to prompt for an answer and update the tree ---
  # ------------------------------------------------------
  prompt_for_answer_and_update <- function(tree_obj, node_name_to_edit) {
    target_node <- FindNode(tree_obj, node_name_to_edit)
    if (is.null(target_node)) {
      cli_alert_danger("Node {.val {node_name_to_edit}} not found.")
      return(tree_obj)
    }
    if (!target_node$isLeaf) {
      cli_alert_danger("Node {.val {node_name_to_edit}} is a parent node. Answers can only be set for leaves.")
      return(tree_obj)
    }

    cli_rule(left = style_bold(glue::glue("Editing Node: {node_name_to_edit}")))
    cli_text(target_node$question)

    # Prompt for new answer
    repeat {
      answer_prompt <- style_bold("Answer (t/true or f/false): ")
      raw_answer <- tolower(trimws(readline(prompt = answer_prompt)))
      if (raw_answer %in% c("t", "true")) { new_answer <- TRUE; break }
      if (raw_answer %in% c("f", "false")) { new_answer <- FALSE; break }
      cli_alert_danger("Invalid input. Please enter 't' or 'f'.")
    }

    # Prompt for new confidence
    repeat {
      conf_prompt <- style_bold("Confidence (0-5): ")
      raw_conf <- trimws(readline(prompt = conf_prompt))
      if (grepl("^[0-5]$", raw_conf)) { new_conf <- as.integer(raw_conf); break }
      cli_alert_danger("Invalid input. Please enter a number between 0 and 5.")
    }

    # Use the package's API to set the answer
    tree_obj <- set_answer(tree_obj, node_name_to_edit, new_answer, new_conf)
    return(tree_obj)
  }

  # ------------------------------------------------------
  # -- Styling (not working)
  # ------------------------------------------------------

  # Define your theme
  white_theme <- list("div.alert" = list("background-color" = "white", "border-color" = "transparent"))
  options(cli.theme = white_theme)
  on.exit(options(cli.theme = NULL))

  # ------------------------------------------------------
  # --- Main Function Logic ---
  # ------------------------------------------------------
  print_intro()
  display_interactive_help()

  # Initialise the tree state
  tree <- update_tree(tree)

  previous_tree_solved <- FALSE

  repeat {
    # Update status variables
    root_node <- tree
    #tree_solved <- !is.na(root_node$answer)
    tree_solved <- !is.null(root_node$answer) && !is.na(root_node$answer)

    if (tree_solved && !previous_tree_solved) {
      cli_alert_success("Conclusion Reached!")
      cli_alert_info(paste0("The current result is: ", root_node$answer, "at a confidence of ", root_node$confidence))
      cli_alert_info("You can now answer more questions or revise existing answers to boost confidence.")
    }

    # The internal confidence is 0.5-1.0; 100% means it's 1.0.
    #tree_finished <- tree_solved && root_node$confidence == 1.0
    tree_finished <- tree_solved && isTRUE(root_node$confidence == 1.0)
    if (tree_finished) {
      cli_alert_success("Tree solved with 100% confidence! Quitting.")
      break
    }

    # Get and display the list of questions
    cli_rule()
    questions_to_ask <- NULL

    if (!tree_solved) {
      cli_h2("Highest Impact Questions")
      questions_to_ask <- get_highest_influence(tree)
    } else {
      cli_h2("Questions to Boost Confidence")
      questions_to_ask <- get_confidence_boosters(tree)
    }

    if (!is.null(questions_to_ask) && nrow(questions_to_ask) > 0) {
      if (!tree_solved) {
        q_list <- setNames(
          glue::glue("[{col_yellow(questions_to_ask$name)}] {col_red(questions_to_ask$influence_index)} {questions_to_ask$question} "),
          1:nrow(questions_to_ask)
        )
      } else {
        #print(questions_to_ask)
        q_list <- setNames(
          glue::glue("[{col_yellow(questions_to_ask$name)}] {questions_to_ask$details} {col_red(questions_to_ask$potential_gain)}"),
          1:nrow(questions_to_ask)
        )
      }
      cli_ol(q_list)
    } else {
      cli_alert_info("No more applicable questions to answer.")
    }
    cli_rule()

    # Get user input
    prompt <- style_bold(col_cyan("Enter a number, 'n', or command (h, p, s, q): "))
    user_input <- tolower(trimws(readline(prompt = prompt)))
    if (user_input == "") next

    # Process user input
    is_numeric_choice <- grepl("^[0-9]+$", user_input)

    if (is_numeric_choice) {
      choice_num <- as.integer(user_input)
      if (!is.null(questions_to_ask) && choice_num > 0 && choice_num <= nrow(questions_to_ask)) {
        node_to_edit <- questions_to_ask$name[choice_num]
        tree <- prompt_for_answer_and_update(tree, node_to_edit)
      } else {
        cli_alert_danger("Invalid number. Please choose from the list.")
      }
    } else {
      switch(user_input,
             "q" = { cli_alert_info("Quitting interactive session."); break },
             "h" = display_interactive_help(),
             # "p" = { cli_h2("Current Tree State"); print_status(tree) },
             "p" = { cli_h2("Current Tree State"); pretty_print(tree) },
             "s" = {
               filename <- readline(prompt = style_bold("Enter filename (e.g., 'tree.rds'): "))
               if (filename != "") {
                 saveRDS(tree, filename)
                 cli_alert_success("Tree saved to {.file {filename}}")
               }
             },
             "n" = {
               node_name <- readline(prompt = style_bold("Enter the node name to edit: "))
               tree <- prompt_for_answer_and_update(tree, node_name)
             },
             cli_alert_danger("Invalid command. Press 'h' for help.")
      )
    }

    # After any action that changes an answer, update the entire tree state
    tree <- update_tree(tree)
    previous_tree_solved <- tree_solved
  }

  cli_h1("Exiting Interactive Mode")
  return(tree)
}
